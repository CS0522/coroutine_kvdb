#include <pthread.h>
#include <memory>
#include <unistd.h>
#include <vector>
#include <algorithm>
#include <cmath>
#include <random>

#include "absl/flags/flag.h"
#include "absl/flags/parse.h"
#include "absl/strings/str_format.h"

#include "remoterocksdb/sync_service_impl.h"

using grpc::Channel;
using grpc::ClientContext;
using grpc::ClientReaderWriter;
using grpc::Status;

using remoterocksdb::Op;
using remoterocksdb::OpReply;
using remoterocksdb::RemoteRocksDBService;
using remoterocksdb::SingleOp;
using remoterocksdb::SingleOpReply;
using std::chrono::duration_cast;
using std::chrono::high_resolution_clock;

#define BATCH_SIZE 100
#define KV_SIZE 1024 // 1KiB

ABSL_FLAG(std::string, target, "127.0.0.1:50051", "Server address");

// 用于生成 zipfian 分布的请求类
template <class IntType = unsigned long, class RealType = double>
class zipf_table_distribution
{
public:
    typedef IntType result_type;

    static_assert(std::numeric_limits<IntType>::is_integer, "");
    static_assert(!std::numeric_limits<RealType>::is_integer, "");

    /// zipf_table_distribution(N, s)
    /// Zipf distribution for `N` items, in the range `[1,N]` inclusive.
    /// The distribution follows the power-law 1/n^s with exponent `s`.
    /// This uses a table-lookup, and thus provides values more
    /// quickly than zipf_distribution. However, the table can take
    /// up a considerable amount of RAM, and initializing this table
    /// can consume significant time.
    zipf_table_distribution(const IntType n,
                            const RealType q = 1.0) : _n(init(n, q)),
                                                      _q(q),
                                                      _dist(_pdf.begin(), _pdf.end())
    {
    }
    void reset() {}

    IntType operator()(std::mt19937_64 &rng)
    {
        return _dist(rng);
    }

    /// Returns the parameter the distribution was constructed with.
    RealType s() const { return _q; }
    /// Returns the minimum value potentially generated by the distribution.
    result_type min() const { return 1; }
    /// Returns the maximum value potentially generated by the distribution.
    result_type max() const { return _n; }

private:
    std::vector<RealType> _pdf;                ///< Prob. distribution
    IntType _n;                                ///< Number of elements
    RealType _q;                               ///< Exponent
    std::discrete_distribution<IntType> _dist; ///< Draw generator

    /** Initialize the probability mass function */
    IntType init(const IntType n, const RealType q)
    {
        _pdf.reserve(n + 1);
        _pdf.emplace_back(0.0);
        for (IntType i = 1; i <= n; i++)
            _pdf.emplace_back(std::pow((double)i, -q));
        return n;
    }
};

class RemoteRocksDBClient
{
public:
    RemoteRocksDBClient(std::shared_ptr<grpc::Channel> channel)
        : stub_(RemoteRocksDBService::NewStub(channel))
    {
        // 一初始化就已经在执行 DoOp
        stream_ = stub_->DoOp(&context_);
    }

    ~RemoteRocksDBClient() {}

    // 暴露 CRUD 接口
    void get(const std::vector<std::string> &keys);
    void put(const std::vector<std::pair<std::string, std::string>> &kvs);

private:
    Status Done();

    std::unique_ptr<RemoteRocksDBService::Stub> stub_;
    ClientContext context_;
    std::unique_ptr<ClientReaderWriter<Op, OpReply>> stream_;

    Op request_;
    OpReply reply_;

    pthread_t DoOp_thread_id;

    std::atomic<uint64_t> op_counter_{0};
    std::atomic<uint64_t> batch_counter_{0};
};

void RemoteRocksDBClient::get(const std::vector<std::string> &keys)
{
    auto start_time = high_resolution_clock::now();

    for (const auto &key : keys)
    {
        op_counter_.fetch_add(1);

        SingleOp *op = request_.add_ops();
        op->set_key(key);
        op->set_type(remoterocksdb::GET);

        if (request_.ops_size() == BATCH_SIZE)
        {
            batch_counter_.fetch_add(1);
            auto batch_start_time = high_resolution_clock::now();

            stream_->Write(request_);

            // Get the value for the sent key
            stream_->Read(&reply_);

            auto batch_end_time = high_resolution_clock::now();
            auto batch_process_time = duration_cast<std::chrono::milliseconds>(batch_end_time - batch_start_time).count();
            std::cout << "Process bacth " << batch_counter_.load()
                      << " in " << std::to_string(batch_process_time) << " millisecs" << std::endl;

            assert(reply_.replies_size() == BATCH_SIZE);
            for (int i = 0; i < reply_.replies_size(); ++i)
            {
                SingleOpReply single_op_rep = reply_.replies(i);
                if (!single_op_rep.ok())
                    std::cout << "Get -> " << request_.ops(i).key() << " failed: " << single_op_rep.status() << std::endl;
                else
                    std::cout << "Get -> " << request_.ops(i).key() << ", returned val: " << single_op_rep.value() << std::endl;
            }
            request_.clear_ops();
            reply_.clear_replies();
        }
    }

    auto end_time = high_resolution_clock::now();
    auto millisecs = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
    std::cout << "send " << keys.size() << " get ops in " << millisecs.count() << " millisecs" << std::endl;
}

void RemoteRocksDBClient::put(const std::vector<std::pair<std::string, std::string>> &kvs)
{
    auto start_time = high_resolution_clock::now();

    #ifdef DEBUG
    std::cout << "Putting..." << std::endl;
    #endif

    for (const auto &kv : kvs)
    {
        op_counter_.fetch_add(1);

        SingleOp *single_op = request_.add_ops();
        single_op->set_key(kv.first);
        single_op->set_value(kv.second);
        single_op->set_type(remoterocksdb::PUT);

        #ifdef DEBUG
        std::cout << "key: " << single_op->key() << ", value: " << single_op->value() 
                    << "type: " << single_op->type() << std::endl;
        #endif

        if (request_.ops_size() == BATCH_SIZE)
        {
            batch_counter_.fetch_add(1);
            auto batch_start_time = high_resolution_clock::now();

            #ifdef DEBUG
            std::cout << "==========" << std::endl;
            std::cout << "Reach BATCH_SIZE, write stream..." << std::endl;
            std::cout << "Current Op size: " << request_.ops_size() << std::endl;
            std::cout << "==========" << std::endl;
            #endif

            stream_->Write(request_);

            auto batch_end_time = high_resolution_clock::now();
            auto batch_process_time = duration_cast<std::chrono::milliseconds>(batch_end_time - batch_start_time).count();
            std::cout << "process batch " << batch_counter_.load()
                      << " in " << std::to_string(batch_process_time) << " millisecs" << std::endl;

            request_.clear_ops();
        }
    }

    this->Done();

    auto end_time = high_resolution_clock::now();
    auto millisecs = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
    std::cout << "send " << kvs.size() << " put ops in "
              << millisecs.count() << " millisecs" << std::endl;
}

Status RemoteRocksDBClient::Done()
{
    stream_->WritesDone();
    Status s = stream_->Finish();
    if (!s.ok())
    {
        std::cout << s.error_code() << ": " << s.error_message()
                  << std::endl;
        std::cout << "RPC failed" << std::endl;
    }
    return s;
}

// 生成 put、get 测试用例
void generate_data(std::vector<std::pair<std::string, std::string>> &kvs, std::vector<std::string> &keys)
{
    uint32_t num_of_kvs = 1000;
    std::random_device rd;
    std::mt19937_64 gen(rd());
    unsigned long n = 1024;
    zipf_table_distribution<unsigned long, double> zipf(n);
    std::default_random_engine eng;
    std::uniform_int_distribution<int> distr(0, 10000);

    std::cout << "zif table initialized" << std::endl;

    // Op request
    for (int i = 0; i < num_of_kvs; i++)
    {
        std::string rand_key = std::bitset<24>(zipf(gen)).to_string();
        std::string rand_val = std::bitset<32>(distr(eng)).to_string();
        // field length 长度置为 KV_SIZE
        rand_val.append(KV_SIZE - rand_val.size(), '0');

        kvs.emplace_back(rand_key, rand_val);
        keys.emplace_back(rand_key);
    }
}

int main(int argc, char **argv)
{
    if (argc < 1)
    {
        std::cout << "Usage: ./db_client --target=";
        return 0;
    }
    absl::ParseCommandLine(argc, argv);
    std::string target_addr = absl::GetFlag(FLAGS_target);

    // 创建客户端
    RemoteRocksDBClient rrdb_client(grpc::CreateChannel(target_addr, grpc::InsecureChannelCredentials()));

    // 生成 data
    std::vector<std::pair<std::string, std::string>> kvs;
    std::vector<std::string> keys;
    generate_data(kvs, keys);

    rrdb_client.put(kvs);
    rrdb_client.get(keys);

    return 0;
}