// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: remote_rocksdb.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_remote_5frocksdb_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_remote_5frocksdb_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_remote_5frocksdb_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_remote_5frocksdb_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_remote_5frocksdb_2eproto;
namespace remoterocksdb {
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class Op;
struct OpDefaultTypeInternal;
extern OpDefaultTypeInternal _Op_default_instance_;
class OpReplies;
struct OpRepliesDefaultTypeInternal;
extern OpRepliesDefaultTypeInternal _OpReplies_default_instance_;
class OpReply;
struct OpReplyDefaultTypeInternal;
extern OpReplyDefaultTypeInternal _OpReply_default_instance_;
class Reply;
struct ReplyDefaultTypeInternal;
extern ReplyDefaultTypeInternal _Reply_default_instance_;
class SingleOp;
struct SingleOpDefaultTypeInternal;
extern SingleOpDefaultTypeInternal _SingleOp_default_instance_;
class SingleOpReply;
struct SingleOpReplyDefaultTypeInternal;
extern SingleOpReplyDefaultTypeInternal _SingleOpReply_default_instance_;
}  // namespace remoterocksdb
PROTOBUF_NAMESPACE_OPEN
template <>
::remoterocksdb::Empty* Arena::CreateMaybeMessage<::remoterocksdb::Empty>(Arena*);
template <>
::remoterocksdb::Op* Arena::CreateMaybeMessage<::remoterocksdb::Op>(Arena*);
template <>
::remoterocksdb::OpReplies* Arena::CreateMaybeMessage<::remoterocksdb::OpReplies>(Arena*);
template <>
::remoterocksdb::OpReply* Arena::CreateMaybeMessage<::remoterocksdb::OpReply>(Arena*);
template <>
::remoterocksdb::Reply* Arena::CreateMaybeMessage<::remoterocksdb::Reply>(Arena*);
template <>
::remoterocksdb::SingleOp* Arena::CreateMaybeMessage<::remoterocksdb::SingleOp>(Arena*);
template <>
::remoterocksdb::SingleOpReply* Arena::CreateMaybeMessage<::remoterocksdb::SingleOpReply>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace remoterocksdb {
enum OpType : int {
  GET = 0,
  PUT = 1,
  DELETE = 2,
  UPDATE = 3,
  SCAN = 4,
  OpType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  OpType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool OpType_IsValid(int value);
constexpr OpType OpType_MIN = static_cast<OpType>(0);
constexpr OpType OpType_MAX = static_cast<OpType>(4);
constexpr int OpType_ARRAYSIZE = 4 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
OpType_descriptor();
template <typename T>
const std::string& OpType_Name(T value) {
  static_assert(std::is_same<T, OpType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OpType_Name().");
  return OpType_Name(static_cast<OpType>(value));
}
template <>
inline const std::string& OpType_Name(OpType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<OpType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool OpType_Parse(absl::string_view name, OpType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OpType>(
      OpType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Op final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remoterocksdb.Op) */ {
 public:
  inline Op() : Op(nullptr) {}
  ~Op() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Op(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Op(const Op& from);
  Op(Op&& from) noexcept
    : Op() {
    *this = ::std::move(from);
  }

  inline Op& operator=(const Op& from) {
    CopyFrom(from);
    return *this;
  }
  inline Op& operator=(Op&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Op& default_instance() {
    return *internal_default_instance();
  }
  static inline const Op* internal_default_instance() {
    return reinterpret_cast<const Op*>(
               &_Op_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Op& a, Op& b) {
    a.Swap(&b);
  }
  inline void Swap(Op* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Op* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Op* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Op>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Op& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Op& from) {
    Op::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Op* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "remoterocksdb.Op";
  }
  protected:
  explicit Op(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEditsFieldNumber = 1,
    kOpsFieldNumber = 2,
    kTimeFieldNumber = 3,
    kIdFieldNumber = 4,
  };
  // repeated string edits = 1;
  int edits_size() const;
  private:
  int _internal_edits_size() const;

  public:
  void clear_edits() ;
  const std::string& edits(int index) const;
  std::string* mutable_edits(int index);
  void set_edits(int index, const std::string& value);
  void set_edits(int index, std::string&& value);
  void set_edits(int index, const char* value);
  void set_edits(int index, const char* value, std::size_t size);
  void set_edits(int index, absl::string_view value);
  std::string* add_edits();
  void add_edits(const std::string& value);
  void add_edits(std::string&& value);
  void add_edits(const char* value);
  void add_edits(const char* value, std::size_t size);
  void add_edits(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& edits() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_edits();

  private:
  const std::string& _internal_edits(int index) const;
  std::string* _internal_add_edits();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_edits() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_edits();

  public:
  // repeated .remoterocksdb.SingleOp ops = 2;
  int ops_size() const;
  private:
  int _internal_ops_size() const;

  public:
  void clear_ops() ;
  ::remoterocksdb::SingleOp* mutable_ops(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remoterocksdb::SingleOp >*
      mutable_ops();
  private:
  const ::remoterocksdb::SingleOp& _internal_ops(int index) const;
  ::remoterocksdb::SingleOp* _internal_add_ops();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::remoterocksdb::SingleOp>& _internal_ops() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::remoterocksdb::SingleOp>* _internal_mutable_ops();
  public:
  const ::remoterocksdb::SingleOp& ops(int index) const;
  ::remoterocksdb::SingleOp* add_ops();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remoterocksdb::SingleOp >&
      ops() const;
  // int64 time = 3;
  void clear_time() ;
  ::int64_t time() const;
  void set_time(::int64_t value);

  private:
  ::int64_t _internal_time() const;
  void _internal_set_time(::int64_t value);

  public:
  // int32 id = 4;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:remoterocksdb.Op)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> edits_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remoterocksdb::SingleOp > ops_;
    ::int64_t time_;
    ::int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_5frocksdb_2eproto;
};// -------------------------------------------------------------------

class OpReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remoterocksdb.OpReply) */ {
 public:
  inline OpReply() : OpReply(nullptr) {}
  ~OpReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OpReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpReply(const OpReply& from);
  OpReply(OpReply&& from) noexcept
    : OpReply() {
    *this = ::std::move(from);
  }

  inline OpReply& operator=(const OpReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpReply& operator=(OpReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpReply* internal_default_instance() {
    return reinterpret_cast<const OpReply*>(
               &_OpReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OpReply& a, OpReply& b) {
    a.Swap(&b);
  }
  inline void Swap(OpReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpReply& from) {
    OpReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "remoterocksdb.OpReply";
  }
  protected:
  explicit OpReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRepliesFieldNumber = 1,
    kTimeFieldNumber = 2,
  };
  // repeated .remoterocksdb.SingleOpReply replies = 1;
  int replies_size() const;
  private:
  int _internal_replies_size() const;

  public:
  void clear_replies() ;
  ::remoterocksdb::SingleOpReply* mutable_replies(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remoterocksdb::SingleOpReply >*
      mutable_replies();
  private:
  const ::remoterocksdb::SingleOpReply& _internal_replies(int index) const;
  ::remoterocksdb::SingleOpReply* _internal_add_replies();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::remoterocksdb::SingleOpReply>& _internal_replies() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::remoterocksdb::SingleOpReply>* _internal_mutable_replies();
  public:
  const ::remoterocksdb::SingleOpReply& replies(int index) const;
  ::remoterocksdb::SingleOpReply* add_replies();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remoterocksdb::SingleOpReply >&
      replies() const;
  // int64 time = 2;
  void clear_time() ;
  ::int64_t time() const;
  void set_time(::int64_t value);

  private:
  ::int64_t _internal_time() const;
  void _internal_set_time(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:remoterocksdb.OpReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remoterocksdb::SingleOpReply > replies_;
    ::int64_t time_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_5frocksdb_2eproto;
};// -------------------------------------------------------------------

class SingleOp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remoterocksdb.SingleOp) */ {
 public:
  inline SingleOp() : SingleOp(nullptr) {}
  ~SingleOp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SingleOp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SingleOp(const SingleOp& from);
  SingleOp(SingleOp&& from) noexcept
    : SingleOp() {
    *this = ::std::move(from);
  }

  inline SingleOp& operator=(const SingleOp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleOp& operator=(SingleOp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SingleOp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SingleOp* internal_default_instance() {
    return reinterpret_cast<const SingleOp*>(
               &_SingleOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SingleOp& a, SingleOp& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleOp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SingleOp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SingleOp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SingleOp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SingleOp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SingleOp& from) {
    SingleOp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleOp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "remoterocksdb.SingleOp";
  }
  protected:
  explicit SingleOp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
    kOpPtrFieldNumber = 4,
    kReplyPtrFieldNumber = 5,
    kTypeFieldNumber = 3,
    kRecordCntFieldNumber = 7,
    kKeynumFieldNumber = 6,
  };
  // string key = 1;
  void clear_key() ;
  const std::string& key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // string value = 2;
  void clear_value() ;
  const std::string& value() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // uint64 op_ptr = 4;
  void clear_op_ptr() ;
  ::uint64_t op_ptr() const;
  void set_op_ptr(::uint64_t value);

  private:
  ::uint64_t _internal_op_ptr() const;
  void _internal_set_op_ptr(::uint64_t value);

  public:
  // uint64 reply_ptr = 5;
  void clear_reply_ptr() ;
  ::uint64_t reply_ptr() const;
  void set_reply_ptr(::uint64_t value);

  private:
  ::uint64_t _internal_reply_ptr() const;
  void _internal_set_reply_ptr(::uint64_t value);

  public:
  // .remoterocksdb.OpType type = 3;
  void clear_type() ;
  ::remoterocksdb::OpType type() const;
  void set_type(::remoterocksdb::OpType value);

  private:
  ::remoterocksdb::OpType _internal_type() const;
  void _internal_set_type(::remoterocksdb::OpType value);

  public:
  // int32 record_cnt = 7;
  void clear_record_cnt() ;
  ::int32_t record_cnt() const;
  void set_record_cnt(::int32_t value);

  private:
  ::int32_t _internal_record_cnt() const;
  void _internal_set_record_cnt(::int32_t value);

  public:
  // int64 keynum = 6;
  void clear_keynum() ;
  ::int64_t keynum() const;
  void set_keynum(::int64_t value);

  private:
  ::int64_t _internal_keynum() const;
  void _internal_set_keynum(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:remoterocksdb.SingleOp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::uint64_t op_ptr_;
    ::uint64_t reply_ptr_;
    int type_;
    ::int32_t record_cnt_;
    ::int64_t keynum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_5frocksdb_2eproto;
};// -------------------------------------------------------------------

class SingleOpReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remoterocksdb.SingleOpReply) */ {
 public:
  inline SingleOpReply() : SingleOpReply(nullptr) {}
  ~SingleOpReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SingleOpReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SingleOpReply(const SingleOpReply& from);
  SingleOpReply(SingleOpReply&& from) noexcept
    : SingleOpReply() {
    *this = ::std::move(from);
  }

  inline SingleOpReply& operator=(const SingleOpReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleOpReply& operator=(SingleOpReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SingleOpReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const SingleOpReply* internal_default_instance() {
    return reinterpret_cast<const SingleOpReply*>(
               &_SingleOpReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SingleOpReply& a, SingleOpReply& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleOpReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SingleOpReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SingleOpReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SingleOpReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SingleOpReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SingleOpReply& from) {
    SingleOpReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleOpReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "remoterocksdb.SingleOpReply";
  }
  protected:
  explicit SingleOpReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScannedValuesFieldNumber = 9,
    kKeyFieldNumber = 2,
    kValueFieldNumber = 3,
    kStatusFieldNumber = 4,
    kOkFieldNumber = 1,
    kTypeFieldNumber = 6,
    kIdFieldNumber = 5,
    kKeynumFieldNumber = 8,
  };
  // repeated string scanned_values = 9;
  int scanned_values_size() const;
  private:
  int _internal_scanned_values_size() const;

  public:
  void clear_scanned_values() ;
  const std::string& scanned_values(int index) const;
  std::string* mutable_scanned_values(int index);
  void set_scanned_values(int index, const std::string& value);
  void set_scanned_values(int index, std::string&& value);
  void set_scanned_values(int index, const char* value);
  void set_scanned_values(int index, const char* value, std::size_t size);
  void set_scanned_values(int index, absl::string_view value);
  std::string* add_scanned_values();
  void add_scanned_values(const std::string& value);
  void add_scanned_values(std::string&& value);
  void add_scanned_values(const char* value);
  void add_scanned_values(const char* value, std::size_t size);
  void add_scanned_values(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& scanned_values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_scanned_values();

  private:
  const std::string& _internal_scanned_values(int index) const;
  std::string* _internal_add_scanned_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& _internal_scanned_values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* _internal_mutable_scanned_values();

  public:
  // string key = 2;
  void clear_key() ;
  const std::string& key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // string value = 3;
  void clear_value() ;
  const std::string& value() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // string status = 4;
  void clear_status() ;
  const std::string& status() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* ptr);

  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(
      const std::string& value);
  std::string* _internal_mutable_status();

  public:
  // bool ok = 1;
  void clear_ok() ;
  bool ok() const;
  void set_ok(bool value);

  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);

  public:
  // .remoterocksdb.OpType type = 6;
  void clear_type() ;
  ::remoterocksdb::OpType type() const;
  void set_type(::remoterocksdb::OpType value);

  private:
  ::remoterocksdb::OpType _internal_type() const;
  void _internal_set_type(::remoterocksdb::OpType value);

  public:
  // int64 Id = 5;
  void clear_id() ;
  ::int64_t id() const;
  void set_id(::int64_t value);

  private:
  ::int64_t _internal_id() const;
  void _internal_set_id(::int64_t value);

  public:
  // int64 keynum = 8;
  void clear_keynum() ;
  ::int64_t keynum() const;
  void set_keynum(::int64_t value);

  private:
  ::int64_t _internal_keynum() const;
  void _internal_set_keynum(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:remoterocksdb.SingleOpReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> scanned_values_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    bool ok_;
    int type_;
    ::int64_t id_;
    ::int64_t keynum_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_5frocksdb_2eproto;
};// -------------------------------------------------------------------

class OpReplies final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remoterocksdb.OpReplies) */ {
 public:
  inline OpReplies() : OpReplies(nullptr) {}
  ~OpReplies() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OpReplies(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpReplies(const OpReplies& from);
  OpReplies(OpReplies&& from) noexcept
    : OpReplies() {
    *this = ::std::move(from);
  }

  inline OpReplies& operator=(const OpReplies& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpReplies& operator=(OpReplies&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpReplies& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpReplies* internal_default_instance() {
    return reinterpret_cast<const OpReplies*>(
               &_OpReplies_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(OpReplies& a, OpReplies& b) {
    a.Swap(&b);
  }
  inline void Swap(OpReplies* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpReplies* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpReplies* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpReplies>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpReplies& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpReplies& from) {
    OpReplies::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpReplies* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "remoterocksdb.OpReplies";
  }
  protected:
  explicit OpReplies(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplyFieldNumber = 1,
  };
  // repeated .remoterocksdb.OpReply reply = 1;
  int reply_size() const;
  private:
  int _internal_reply_size() const;

  public:
  void clear_reply() ;
  ::remoterocksdb::OpReply* mutable_reply(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remoterocksdb::OpReply >*
      mutable_reply();
  private:
  const ::remoterocksdb::OpReply& _internal_reply(int index) const;
  ::remoterocksdb::OpReply* _internal_add_reply();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::remoterocksdb::OpReply>& _internal_reply() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::remoterocksdb::OpReply>* _internal_mutable_reply();
  public:
  const ::remoterocksdb::OpReply& reply(int index) const;
  ::remoterocksdb::OpReply* add_reply();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remoterocksdb::OpReply >&
      reply() const;
  // @@protoc_insertion_point(class_scope:remoterocksdb.OpReplies)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remoterocksdb::OpReply > reply_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_5frocksdb_2eproto;
};// -------------------------------------------------------------------

class Reply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:remoterocksdb.Reply) */ {
 public:
  inline Reply() : Reply(nullptr) {}
  ~Reply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Reply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Reply(const Reply& from);
  Reply(Reply&& from) noexcept
    : Reply() {
    *this = ::std::move(from);
  }

  inline Reply& operator=(const Reply& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reply& operator=(Reply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Reply& default_instance() {
    return *internal_default_instance();
  }
  static inline const Reply* internal_default_instance() {
    return reinterpret_cast<const Reply*>(
               &_Reply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Reply& a, Reply& b) {
    a.Swap(&b);
  }
  inline void Swap(Reply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Reply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Reply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Reply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Reply& from) {
    Reply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "remoterocksdb.Reply";
  }
  protected:
  explicit Reply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok() ;
  bool ok() const;
  void set_ok(bool value);

  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);

  public:
  // @@protoc_insertion_point(class_scope:remoterocksdb.Reply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_remote_5frocksdb_2eproto;
};// -------------------------------------------------------------------

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:remoterocksdb.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "remoterocksdb.Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:remoterocksdb.Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_remote_5frocksdb_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Op

// repeated string edits = 1;
inline int Op::_internal_edits_size() const {
  return _impl_.edits_.size();
}
inline int Op::edits_size() const {
  return _internal_edits_size();
}
inline void Op::clear_edits() {
  _internal_mutable_edits()->Clear();
}
inline std::string* Op::add_edits() {
  std::string* _s = _internal_add_edits();
  // @@protoc_insertion_point(field_add_mutable:remoterocksdb.Op.edits)
  return _s;
}
inline const std::string& Op::edits(int index) const {
  // @@protoc_insertion_point(field_get:remoterocksdb.Op.edits)
  return _internal_edits(index);
}
inline std::string* Op::mutable_edits(int index) {
  // @@protoc_insertion_point(field_mutable:remoterocksdb.Op.edits)
  return _internal_mutable_edits()->Mutable(index);
}
inline void Op::set_edits(int index, const std::string& value) {
  _internal_mutable_edits()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:remoterocksdb.Op.edits)
}
inline void Op::set_edits(int index, std::string&& value) {
  _internal_mutable_edits()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:remoterocksdb.Op.edits)
}
inline void Op::set_edits(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_edits()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:remoterocksdb.Op.edits)
}
inline void Op::set_edits(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_edits()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:remoterocksdb.Op.edits)
}
inline void Op::set_edits(int index, absl::string_view value) {
  _internal_mutable_edits()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:remoterocksdb.Op.edits)
}
inline void Op::add_edits(const std::string& value) {
  _internal_mutable_edits()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:remoterocksdb.Op.edits)
}
inline void Op::add_edits(std::string&& value) {
  _internal_mutable_edits()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:remoterocksdb.Op.edits)
}
inline void Op::add_edits(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_edits()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:remoterocksdb.Op.edits)
}
inline void Op::add_edits(const char* value, std::size_t size) {
  _internal_mutable_edits()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:remoterocksdb.Op.edits)
}
inline void Op::add_edits(absl::string_view value) {
  _internal_mutable_edits()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:remoterocksdb.Op.edits)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Op::edits() const {
  // @@protoc_insertion_point(field_list:remoterocksdb.Op.edits)
  return _internal_edits();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* Op::mutable_edits() {
  // @@protoc_insertion_point(field_mutable_list:remoterocksdb.Op.edits)
  return _internal_mutable_edits();
}
inline const std::string& Op::_internal_edits(int index) const {
  return _internal_edits().Get(index);
}
inline std::string* Op::_internal_add_edits() {
  return _internal_mutable_edits()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Op::_internal_edits() const {
  return _impl_.edits_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Op::_internal_mutable_edits() {
  return &_impl_.edits_;
}

// repeated .remoterocksdb.SingleOp ops = 2;
inline int Op::_internal_ops_size() const {
  return _impl_.ops_.size();
}
inline int Op::ops_size() const {
  return _internal_ops_size();
}
inline void Op::clear_ops() {
  _internal_mutable_ops()->Clear();
}
inline ::remoterocksdb::SingleOp* Op::mutable_ops(int index) {
  // @@protoc_insertion_point(field_mutable:remoterocksdb.Op.ops)
  return _internal_mutable_ops()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remoterocksdb::SingleOp >*
Op::mutable_ops() {
  // @@protoc_insertion_point(field_mutable_list:remoterocksdb.Op.ops)
  return _internal_mutable_ops();
}
inline const ::remoterocksdb::SingleOp& Op::_internal_ops(int index) const {
  return _internal_ops().Get(index);
}
inline const ::remoterocksdb::SingleOp& Op::ops(int index) const {
  // @@protoc_insertion_point(field_get:remoterocksdb.Op.ops)
  return _internal_ops(index);
}
inline ::remoterocksdb::SingleOp* Op::_internal_add_ops() {
  return _internal_mutable_ops()->Add();
}
inline ::remoterocksdb::SingleOp* Op::add_ops() {
  ::remoterocksdb::SingleOp* _add = _internal_add_ops();
  // @@protoc_insertion_point(field_add:remoterocksdb.Op.ops)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remoterocksdb::SingleOp >&
Op::ops() const {
  // @@protoc_insertion_point(field_list:remoterocksdb.Op.ops)
  return _internal_ops();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::remoterocksdb::SingleOp>&
Op::_internal_ops() const {
  return _impl_.ops_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::remoterocksdb::SingleOp>*
Op::_internal_mutable_ops() {
  return &_impl_.ops_;
}

// int64 time = 3;
inline void Op::clear_time() {
  _impl_.time_ = ::int64_t{0};
}
inline ::int64_t Op::time() const {
  // @@protoc_insertion_point(field_get:remoterocksdb.Op.time)
  return _internal_time();
}
inline void Op::set_time(::int64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:remoterocksdb.Op.time)
}
inline ::int64_t Op::_internal_time() const {
  return _impl_.time_;
}
inline void Op::_internal_set_time(::int64_t value) {
  ;
  _impl_.time_ = value;
}

// int32 id = 4;
inline void Op::clear_id() {
  _impl_.id_ = 0;
}
inline ::int32_t Op::id() const {
  // @@protoc_insertion_point(field_get:remoterocksdb.Op.id)
  return _internal_id();
}
inline void Op::set_id(::int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:remoterocksdb.Op.id)
}
inline ::int32_t Op::_internal_id() const {
  return _impl_.id_;
}
inline void Op::_internal_set_id(::int32_t value) {
  ;
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// OpReply

// repeated .remoterocksdb.SingleOpReply replies = 1;
inline int OpReply::_internal_replies_size() const {
  return _impl_.replies_.size();
}
inline int OpReply::replies_size() const {
  return _internal_replies_size();
}
inline void OpReply::clear_replies() {
  _internal_mutable_replies()->Clear();
}
inline ::remoterocksdb::SingleOpReply* OpReply::mutable_replies(int index) {
  // @@protoc_insertion_point(field_mutable:remoterocksdb.OpReply.replies)
  return _internal_mutable_replies()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remoterocksdb::SingleOpReply >*
OpReply::mutable_replies() {
  // @@protoc_insertion_point(field_mutable_list:remoterocksdb.OpReply.replies)
  return _internal_mutable_replies();
}
inline const ::remoterocksdb::SingleOpReply& OpReply::_internal_replies(int index) const {
  return _internal_replies().Get(index);
}
inline const ::remoterocksdb::SingleOpReply& OpReply::replies(int index) const {
  // @@protoc_insertion_point(field_get:remoterocksdb.OpReply.replies)
  return _internal_replies(index);
}
inline ::remoterocksdb::SingleOpReply* OpReply::_internal_add_replies() {
  return _internal_mutable_replies()->Add();
}
inline ::remoterocksdb::SingleOpReply* OpReply::add_replies() {
  ::remoterocksdb::SingleOpReply* _add = _internal_add_replies();
  // @@protoc_insertion_point(field_add:remoterocksdb.OpReply.replies)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remoterocksdb::SingleOpReply >&
OpReply::replies() const {
  // @@protoc_insertion_point(field_list:remoterocksdb.OpReply.replies)
  return _internal_replies();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::remoterocksdb::SingleOpReply>&
OpReply::_internal_replies() const {
  return _impl_.replies_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::remoterocksdb::SingleOpReply>*
OpReply::_internal_mutable_replies() {
  return &_impl_.replies_;
}

// int64 time = 2;
inline void OpReply::clear_time() {
  _impl_.time_ = ::int64_t{0};
}
inline ::int64_t OpReply::time() const {
  // @@protoc_insertion_point(field_get:remoterocksdb.OpReply.time)
  return _internal_time();
}
inline void OpReply::set_time(::int64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:remoterocksdb.OpReply.time)
}
inline ::int64_t OpReply::_internal_time() const {
  return _impl_.time_;
}
inline void OpReply::_internal_set_time(::int64_t value) {
  ;
  _impl_.time_ = value;
}

// -------------------------------------------------------------------

// SingleOp

// string key = 1;
inline void SingleOp::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& SingleOp::key() const {
  // @@protoc_insertion_point(field_get:remoterocksdb.SingleOp.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SingleOp::set_key(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remoterocksdb.SingleOp.key)
}
inline std::string* SingleOp::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:remoterocksdb.SingleOp.key)
  return _s;
}
inline const std::string& SingleOp::_internal_key() const {
  return _impl_.key_.Get();
}
inline void SingleOp::_internal_set_key(const std::string& value) {
  ;


  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* SingleOp::_internal_mutable_key() {
  ;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* SingleOp::release_key() {
  // @@protoc_insertion_point(field_release:remoterocksdb.SingleOp.key)
  return _impl_.key_.Release();
}
inline void SingleOp::set_allocated_key(std::string* value) {
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remoterocksdb.SingleOp.key)
}

// string value = 2;
inline void SingleOp::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& SingleOp::value() const {
  // @@protoc_insertion_point(field_get:remoterocksdb.SingleOp.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SingleOp::set_value(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remoterocksdb.SingleOp.value)
}
inline std::string* SingleOp::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:remoterocksdb.SingleOp.value)
  return _s;
}
inline const std::string& SingleOp::_internal_value() const {
  return _impl_.value_.Get();
}
inline void SingleOp::_internal_set_value(const std::string& value) {
  ;


  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* SingleOp::_internal_mutable_value() {
  ;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* SingleOp::release_value() {
  // @@protoc_insertion_point(field_release:remoterocksdb.SingleOp.value)
  return _impl_.value_.Release();
}
inline void SingleOp::set_allocated_value(std::string* value) {
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remoterocksdb.SingleOp.value)
}

// .remoterocksdb.OpType type = 3;
inline void SingleOp::clear_type() {
  _impl_.type_ = 0;
}
inline ::remoterocksdb::OpType SingleOp::type() const {
  // @@protoc_insertion_point(field_get:remoterocksdb.SingleOp.type)
  return _internal_type();
}
inline void SingleOp::set_type(::remoterocksdb::OpType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:remoterocksdb.SingleOp.type)
}
inline ::remoterocksdb::OpType SingleOp::_internal_type() const {
  return static_cast<::remoterocksdb::OpType>(_impl_.type_);
}
inline void SingleOp::_internal_set_type(::remoterocksdb::OpType value) {
  ;
  _impl_.type_ = value;
}

// uint64 op_ptr = 4;
inline void SingleOp::clear_op_ptr() {
  _impl_.op_ptr_ = ::uint64_t{0u};
}
inline ::uint64_t SingleOp::op_ptr() const {
  // @@protoc_insertion_point(field_get:remoterocksdb.SingleOp.op_ptr)
  return _internal_op_ptr();
}
inline void SingleOp::set_op_ptr(::uint64_t value) {
  _internal_set_op_ptr(value);
  // @@protoc_insertion_point(field_set:remoterocksdb.SingleOp.op_ptr)
}
inline ::uint64_t SingleOp::_internal_op_ptr() const {
  return _impl_.op_ptr_;
}
inline void SingleOp::_internal_set_op_ptr(::uint64_t value) {
  ;
  _impl_.op_ptr_ = value;
}

// uint64 reply_ptr = 5;
inline void SingleOp::clear_reply_ptr() {
  _impl_.reply_ptr_ = ::uint64_t{0u};
}
inline ::uint64_t SingleOp::reply_ptr() const {
  // @@protoc_insertion_point(field_get:remoterocksdb.SingleOp.reply_ptr)
  return _internal_reply_ptr();
}
inline void SingleOp::set_reply_ptr(::uint64_t value) {
  _internal_set_reply_ptr(value);
  // @@protoc_insertion_point(field_set:remoterocksdb.SingleOp.reply_ptr)
}
inline ::uint64_t SingleOp::_internal_reply_ptr() const {
  return _impl_.reply_ptr_;
}
inline void SingleOp::_internal_set_reply_ptr(::uint64_t value) {
  ;
  _impl_.reply_ptr_ = value;
}

// int64 keynum = 6;
inline void SingleOp::clear_keynum() {
  _impl_.keynum_ = ::int64_t{0};
}
inline ::int64_t SingleOp::keynum() const {
  // @@protoc_insertion_point(field_get:remoterocksdb.SingleOp.keynum)
  return _internal_keynum();
}
inline void SingleOp::set_keynum(::int64_t value) {
  _internal_set_keynum(value);
  // @@protoc_insertion_point(field_set:remoterocksdb.SingleOp.keynum)
}
inline ::int64_t SingleOp::_internal_keynum() const {
  return _impl_.keynum_;
}
inline void SingleOp::_internal_set_keynum(::int64_t value) {
  ;
  _impl_.keynum_ = value;
}

// int32 record_cnt = 7;
inline void SingleOp::clear_record_cnt() {
  _impl_.record_cnt_ = 0;
}
inline ::int32_t SingleOp::record_cnt() const {
  // @@protoc_insertion_point(field_get:remoterocksdb.SingleOp.record_cnt)
  return _internal_record_cnt();
}
inline void SingleOp::set_record_cnt(::int32_t value) {
  _internal_set_record_cnt(value);
  // @@protoc_insertion_point(field_set:remoterocksdb.SingleOp.record_cnt)
}
inline ::int32_t SingleOp::_internal_record_cnt() const {
  return _impl_.record_cnt_;
}
inline void SingleOp::_internal_set_record_cnt(::int32_t value) {
  ;
  _impl_.record_cnt_ = value;
}

// -------------------------------------------------------------------

// SingleOpReply

// bool ok = 1;
inline void SingleOpReply::clear_ok() {
  _impl_.ok_ = false;
}
inline bool SingleOpReply::ok() const {
  // @@protoc_insertion_point(field_get:remoterocksdb.SingleOpReply.ok)
  return _internal_ok();
}
inline void SingleOpReply::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:remoterocksdb.SingleOpReply.ok)
}
inline bool SingleOpReply::_internal_ok() const {
  return _impl_.ok_;
}
inline void SingleOpReply::_internal_set_ok(bool value) {
  ;
  _impl_.ok_ = value;
}

// string key = 2;
inline void SingleOpReply::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& SingleOpReply::key() const {
  // @@protoc_insertion_point(field_get:remoterocksdb.SingleOpReply.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SingleOpReply::set_key(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remoterocksdb.SingleOpReply.key)
}
inline std::string* SingleOpReply::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:remoterocksdb.SingleOpReply.key)
  return _s;
}
inline const std::string& SingleOpReply::_internal_key() const {
  return _impl_.key_.Get();
}
inline void SingleOpReply::_internal_set_key(const std::string& value) {
  ;


  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* SingleOpReply::_internal_mutable_key() {
  ;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* SingleOpReply::release_key() {
  // @@protoc_insertion_point(field_release:remoterocksdb.SingleOpReply.key)
  return _impl_.key_.Release();
}
inline void SingleOpReply::set_allocated_key(std::string* value) {
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remoterocksdb.SingleOpReply.key)
}

// string value = 3;
inline void SingleOpReply::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& SingleOpReply::value() const {
  // @@protoc_insertion_point(field_get:remoterocksdb.SingleOpReply.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SingleOpReply::set_value(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remoterocksdb.SingleOpReply.value)
}
inline std::string* SingleOpReply::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:remoterocksdb.SingleOpReply.value)
  return _s;
}
inline const std::string& SingleOpReply::_internal_value() const {
  return _impl_.value_.Get();
}
inline void SingleOpReply::_internal_set_value(const std::string& value) {
  ;


  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* SingleOpReply::_internal_mutable_value() {
  ;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* SingleOpReply::release_value() {
  // @@protoc_insertion_point(field_release:remoterocksdb.SingleOpReply.value)
  return _impl_.value_.Release();
}
inline void SingleOpReply::set_allocated_value(std::string* value) {
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remoterocksdb.SingleOpReply.value)
}

// string status = 4;
inline void SingleOpReply::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& SingleOpReply::status() const {
  // @@protoc_insertion_point(field_get:remoterocksdb.SingleOpReply.status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SingleOpReply::set_status(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.status_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:remoterocksdb.SingleOpReply.status)
}
inline std::string* SingleOpReply::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:remoterocksdb.SingleOpReply.status)
  return _s;
}
inline const std::string& SingleOpReply::_internal_status() const {
  return _impl_.status_.Get();
}
inline void SingleOpReply::_internal_set_status(const std::string& value) {
  ;


  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* SingleOpReply::_internal_mutable_status() {
  ;
  return _impl_.status_.Mutable( GetArenaForAllocation());
}
inline std::string* SingleOpReply::release_status() {
  // @@protoc_insertion_point(field_release:remoterocksdb.SingleOpReply.status)
  return _impl_.status_.Release();
}
inline void SingleOpReply::set_allocated_status(std::string* value) {
  _impl_.status_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.status_.IsDefault()) {
          _impl_.status_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:remoterocksdb.SingleOpReply.status)
}

// int64 Id = 5;
inline void SingleOpReply::clear_id() {
  _impl_.id_ = ::int64_t{0};
}
inline ::int64_t SingleOpReply::id() const {
  // @@protoc_insertion_point(field_get:remoterocksdb.SingleOpReply.Id)
  return _internal_id();
}
inline void SingleOpReply::set_id(::int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:remoterocksdb.SingleOpReply.Id)
}
inline ::int64_t SingleOpReply::_internal_id() const {
  return _impl_.id_;
}
inline void SingleOpReply::_internal_set_id(::int64_t value) {
  ;
  _impl_.id_ = value;
}

// .remoterocksdb.OpType type = 6;
inline void SingleOpReply::clear_type() {
  _impl_.type_ = 0;
}
inline ::remoterocksdb::OpType SingleOpReply::type() const {
  // @@protoc_insertion_point(field_get:remoterocksdb.SingleOpReply.type)
  return _internal_type();
}
inline void SingleOpReply::set_type(::remoterocksdb::OpType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:remoterocksdb.SingleOpReply.type)
}
inline ::remoterocksdb::OpType SingleOpReply::_internal_type() const {
  return static_cast<::remoterocksdb::OpType>(_impl_.type_);
}
inline void SingleOpReply::_internal_set_type(::remoterocksdb::OpType value) {
  ;
  _impl_.type_ = value;
}

// int64 keynum = 8;
inline void SingleOpReply::clear_keynum() {
  _impl_.keynum_ = ::int64_t{0};
}
inline ::int64_t SingleOpReply::keynum() const {
  // @@protoc_insertion_point(field_get:remoterocksdb.SingleOpReply.keynum)
  return _internal_keynum();
}
inline void SingleOpReply::set_keynum(::int64_t value) {
  _internal_set_keynum(value);
  // @@protoc_insertion_point(field_set:remoterocksdb.SingleOpReply.keynum)
}
inline ::int64_t SingleOpReply::_internal_keynum() const {
  return _impl_.keynum_;
}
inline void SingleOpReply::_internal_set_keynum(::int64_t value) {
  ;
  _impl_.keynum_ = value;
}

// repeated string scanned_values = 9;
inline int SingleOpReply::_internal_scanned_values_size() const {
  return _impl_.scanned_values_.size();
}
inline int SingleOpReply::scanned_values_size() const {
  return _internal_scanned_values_size();
}
inline void SingleOpReply::clear_scanned_values() {
  _internal_mutable_scanned_values()->Clear();
}
inline std::string* SingleOpReply::add_scanned_values() {
  std::string* _s = _internal_add_scanned_values();
  // @@protoc_insertion_point(field_add_mutable:remoterocksdb.SingleOpReply.scanned_values)
  return _s;
}
inline const std::string& SingleOpReply::scanned_values(int index) const {
  // @@protoc_insertion_point(field_get:remoterocksdb.SingleOpReply.scanned_values)
  return _internal_scanned_values(index);
}
inline std::string* SingleOpReply::mutable_scanned_values(int index) {
  // @@protoc_insertion_point(field_mutable:remoterocksdb.SingleOpReply.scanned_values)
  return _internal_mutable_scanned_values()->Mutable(index);
}
inline void SingleOpReply::set_scanned_values(int index, const std::string& value) {
  _internal_mutable_scanned_values()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:remoterocksdb.SingleOpReply.scanned_values)
}
inline void SingleOpReply::set_scanned_values(int index, std::string&& value) {
  _internal_mutable_scanned_values()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:remoterocksdb.SingleOpReply.scanned_values)
}
inline void SingleOpReply::set_scanned_values(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_scanned_values()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:remoterocksdb.SingleOpReply.scanned_values)
}
inline void SingleOpReply::set_scanned_values(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_scanned_values()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:remoterocksdb.SingleOpReply.scanned_values)
}
inline void SingleOpReply::set_scanned_values(int index, absl::string_view value) {
  _internal_mutable_scanned_values()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:remoterocksdb.SingleOpReply.scanned_values)
}
inline void SingleOpReply::add_scanned_values(const std::string& value) {
  _internal_mutable_scanned_values()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:remoterocksdb.SingleOpReply.scanned_values)
}
inline void SingleOpReply::add_scanned_values(std::string&& value) {
  _internal_mutable_scanned_values()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:remoterocksdb.SingleOpReply.scanned_values)
}
inline void SingleOpReply::add_scanned_values(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_scanned_values()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:remoterocksdb.SingleOpReply.scanned_values)
}
inline void SingleOpReply::add_scanned_values(const char* value, std::size_t size) {
  _internal_mutable_scanned_values()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:remoterocksdb.SingleOpReply.scanned_values)
}
inline void SingleOpReply::add_scanned_values(absl::string_view value) {
  _internal_mutable_scanned_values()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:remoterocksdb.SingleOpReply.scanned_values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SingleOpReply::scanned_values() const {
  // @@protoc_insertion_point(field_list:remoterocksdb.SingleOpReply.scanned_values)
  return _internal_scanned_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* SingleOpReply::mutable_scanned_values() {
  // @@protoc_insertion_point(field_mutable_list:remoterocksdb.SingleOpReply.scanned_values)
  return _internal_mutable_scanned_values();
}
inline const std::string& SingleOpReply::_internal_scanned_values(int index) const {
  return _internal_scanned_values().Get(index);
}
inline std::string* SingleOpReply::_internal_add_scanned_values() {
  return _internal_mutable_scanned_values()->Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SingleOpReply::_internal_scanned_values() const {
  return _impl_.scanned_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SingleOpReply::_internal_mutable_scanned_values() {
  return &_impl_.scanned_values_;
}

// -------------------------------------------------------------------

// OpReplies

// repeated .remoterocksdb.OpReply reply = 1;
inline int OpReplies::_internal_reply_size() const {
  return _impl_.reply_.size();
}
inline int OpReplies::reply_size() const {
  return _internal_reply_size();
}
inline void OpReplies::clear_reply() {
  _internal_mutable_reply()->Clear();
}
inline ::remoterocksdb::OpReply* OpReplies::mutable_reply(int index) {
  // @@protoc_insertion_point(field_mutable:remoterocksdb.OpReplies.reply)
  return _internal_mutable_reply()->Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remoterocksdb::OpReply >*
OpReplies::mutable_reply() {
  // @@protoc_insertion_point(field_mutable_list:remoterocksdb.OpReplies.reply)
  return _internal_mutable_reply();
}
inline const ::remoterocksdb::OpReply& OpReplies::_internal_reply(int index) const {
  return _internal_reply().Get(index);
}
inline const ::remoterocksdb::OpReply& OpReplies::reply(int index) const {
  // @@protoc_insertion_point(field_get:remoterocksdb.OpReplies.reply)
  return _internal_reply(index);
}
inline ::remoterocksdb::OpReply* OpReplies::_internal_add_reply() {
  return _internal_mutable_reply()->Add();
}
inline ::remoterocksdb::OpReply* OpReplies::add_reply() {
  ::remoterocksdb::OpReply* _add = _internal_add_reply();
  // @@protoc_insertion_point(field_add:remoterocksdb.OpReplies.reply)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::remoterocksdb::OpReply >&
OpReplies::reply() const {
  // @@protoc_insertion_point(field_list:remoterocksdb.OpReplies.reply)
  return _internal_reply();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::remoterocksdb::OpReply>&
OpReplies::_internal_reply() const {
  return _impl_.reply_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::remoterocksdb::OpReply>*
OpReplies::_internal_mutable_reply() {
  return &_impl_.reply_;
}

// -------------------------------------------------------------------

// Reply

// bool ok = 1;
inline void Reply::clear_ok() {
  _impl_.ok_ = false;
}
inline bool Reply::ok() const {
  // @@protoc_insertion_point(field_get:remoterocksdb.Reply.ok)
  return _internal_ok();
}
inline void Reply::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:remoterocksdb.Reply.ok)
}
inline bool Reply::_internal_ok() const {
  return _impl_.ok_;
}
inline void Reply::_internal_set_ok(bool value) {
  ;
  _impl_.ok_ = value;
}

// -------------------------------------------------------------------

// Empty

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace remoterocksdb


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::remoterocksdb::OpType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::remoterocksdb::OpType>() {
  return ::remoterocksdb::OpType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_remote_5frocksdb_2eproto_2epb_2eh
